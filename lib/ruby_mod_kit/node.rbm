# frozen_string_literal: true

# rbs_inline: enabled

module RubyModKit
  # The class of transpile node.
  class Node
    attr_reader :parent #: Node | nil

    @parent: Node | nil
    @children: Array[Node]
    @ancestors: Array[Node]

    def children : (Array[Node])
      return @children if @children

      @children = prism_node.child_nodes.compact.map do |prism_child_node|
        wrap(prism_child_node)
      end
    end

    def wrap(Prism::Node => prism_node): Node
      case prism_node
      when Prism::ClassNode
        Node::ClassNode.new(prism_node, parent: self)
      when Prism::ModuleNode
        Node::ModuleNode.new(prism_node, parent: self)
      when Prism::DefNode
        Node::DefNode.new(prism_node, parent: self)
      when Prism::RequiredParameterNode, Prism::OptionalKeywordParameterNode,
           Prism::OptionalParameterNode, Prism::RequiredKeywordParameterNode
        Node::ParameterNode.new(prism_node, parent: self)
      when Prism::StatementsNode
        Node::StatementsNode.new(prism_node, parent: self)
      else
        Node::UntypedNode.new(prism_node, parent: self)
      end
    end

    def ancestors : (Array[Node])
      return @ancestors if @ancestors

      parent = @parent
      @ancestors = if parent
        [parent] + parent.ancestors
      else
        []
      end
    end

    def name: Symbol
      raise(RubyModKit::Error, "Expected ParameterNode but #{self.class}:#{prism_node.inspect}")
    end

    def [](Integer => offset, (Class | nil) => prism_klass = nil): (Node | nil)
      return nil unless include?(offset)

      child = children.find { _1.include?(offset) }
      node = child&.[](offset) || self
      return node unless prism_klass
      return node if node.prism_node.is_a?(prism_klass)

      node.ancestors.find { _1.prism_node.is_a?(prism_klass) }
    end

    def include?(Integer => offset): bool
      self.offset <= offset && offset <= prism_node.location.end_offset
    end

    def prism_node: (Prism::Node & Prism::_Node)
      raise RubyModKit::Error
    end

    def offset: Integer
      prism_node.location.start_offset
    end

    def inspect: String
      str = +"#<#{self.class} "
      first = true
      instance_variables.each do |ivar_name|
        case ivar_name
        when :@children, :@ancestors, :@parent
          next
        end

        if first
          first = false
        else
          str << ", "
        end
        str << "#{ivar_name}="
        value = instance_variable_get(ivar_name)
        str << (
          case value
          when Prism::Node
            "#<#{value.class} location=#{value.location.inspect}>"
          else
            value.inspect
          end
        )
      end
      str << ">"
      str
    end
  end
end

require_relative "node/class_node"
require_relative "node/def_node"
require_relative "node/module_node"
require_relative "node/parameter_node"
require_relative "node/program_node"
require_relative "node/statements_node"
require_relative "node/untyped_node"
